# -*- coding: utf-8 -*-
"""Item_Colab_KMeans_Recommender.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1e5WA2LxunNZJSRyONsa6gb_RwQdLr-Vq
"""

# from google.colab import drive
# drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
# %cd '/content/drive/My Drive/Colab Notebooks/'
# %run Data_Parser.ipynb

import numpy as np
import matplotlib.pyplot as plt
from scipy.sparse import coo_matrix
from sklearn.cluster import KMeans

#takes in a binary array that specifies which fields to use in the game vector
def create_game_vector(binarray):

	vector_set = set()

	# retrieve all distinct values for desired fields
	# and store each set into a list
	if binarray[0]:
		publisher_set = get_all_distinct_values(3, 'publisher')
		print('Using ' + str(len(publisher_set)) + ' publishers.')
		vector_set = vector_set.union(publisher_set)
	if binarray[1]:
		developer_set = get_all_distinct_values(3, 'developer')
		print('Using ' + str(len(developer_set)) + ' developers.')
		vector_set = vector_set.union(developer_set)
	if binarray[2]:
		genre_set = get_all_distinct_values(3, 'genres')
		print('Using ' + str(len(genre_set)) + ' genres.')
		vector_set = vector_set.union(genre_set)
	if binarray[3]:
		spec_set = get_all_distinct_values(3, 'specs')
		print('Using ' + str(len(spec_set)) + ' specs.')
		vector_set = vector_set.union(spec_set)
	if binarray[4]:
		tag_set = get_all_distinct_values(3, 'tags')
		print('Using ' + str(len(tag_set)) + ' tags.')
		vector_set = vector_set.union(tag_set)

	print(len(vector_set))

	game_vector = list(vector_set)

	print(len(game_vector))

	return game_vector

def create_sparse_matrix(binarray):

  feature_vector = create_game_vector(binarray)
  data = []
  i = []
  j = []

  #loop through games
  row_index = 0
  games = output_parse_generator(steam_games_path, size_steam_games)
  
  print('Creating Sparse Matrix...')

  for game_dict in games:

    if binarray[0]: # publishers (single)
      try:
        publisher = game_dict['publisher']
        col_index = feature_vector.index(publisher)
        data.append(1)
        i.append(row_index)
        j.append(col_index)
      except KeyError:
        pass
    if binarray[1]: # developers (single)
      try:
        developer = game_dict['developer']
        col_index = feature_vector.index(developer)
        data.append(1)
        i.append(row_index)
        j.append(col_index)
      except KeyError:
        pass
    if binarray[2]: # genres (multiple)
      try:
        genres = game_dict['genres']
        for genre in genres:
          col_index = feature_vector.index(genre)
          data.append(1)
          i.append(row_index)
          j.append(col_index)
      except KeyError:
        pass
    if binarray[3]: # specs (multiple)
      try:
        specs = game_dict['specs']
        for spec in specs:
          col_index = feature_vector.index(spec)
          data.append(1)
          i.append(row_index)
          j.append(col_index)
      except KeyError:
        pass
    if binarray[4]: # tags (multiple)
      try:
        tags = game_dict['tags']
        for tag in tags:
          col_index = feature_vector.index(tag)
          data.append(1)
          i.append(row_index)
          j.append(col_index)
      except KeyError:
        pass

    row_index += 1

  sparse_matrix = coo_matrix((data, (i, j))) # create coo_matrix 
  sparse_matrix = sparse_matrix.tocsr() # convert to csr_matrix

  print('Matrix Created with Shape ', sparse_matrix.shape)

  return sparse_matrix, feature_vector

def create_clusters(sparse_matrix, n_clusters=8, n_centroid_seed_tests=10, max_iter=300):

  print('Creating '+ str(n_clusters) +' Clusters...')

  kmeans = KMeans(n_clusters=n_clusters, n_init=n_centroid_seed_tests, max_iter=max_iter, init='random', tol=0.0001).fit(sparse_matrix)
  print('Clustering Score: ' + str(kmeans.inertia_)) # output the score of the data
  transform = kmeans.transform(sparse_matrix)
  # print('Transform: ' + str(transform))
  # print('Transform Shape: ' + str(len(transform)) + ',' + str(len(transform[0])))

  return kmeans

def test_for_clusters(sparse_matrix):

  scores = []
  clusters = []
  for k in range(500, 10000, 500):#  k = 9500 -> 40202 (probably just choose an even 10,000 or 1,000?)
    model = create_clusters(sparse_matrix, n_clusters=k)
    scores.append(model.inertia_)
    clusters.append(k)

  plt.plot(clusters, scores)
  plt.show()

matrix, feature_vector = create_sparse_matrix([False, True, True, True, True])
create_clusters(matrix, n_clusters=10000)